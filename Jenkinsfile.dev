pipeline {
    agent any

    parameters {
        choice(
            name: 'ACTION',
            choices: ['deploy', 'build-base'],
            description: '실행할 작업 선택 (build-base: Base 이미지 빌드)'
        )
        string(
            name: 'BRANCH',
            defaultValue: 'develop',
            description: '배포할 브랜치 또는 태그'
        )
    }

    environment {
        // 프로젝트 설정
        PROJECT_NAME = 'laravel-commu-dev'
        DEPLOY_PATH = '/var/www/laravel-commu-dev'

        // Docker 설정
        DOCKER_IMAGE_BASE = 'laravel-commu-base'
        DEV_PORT = '10100'

        // GitHub 설정
        GIT_REPO = 'git@github.com:shaul1991/laravel-commu.git'
        GIT_CREDENTIALS_ID = 'home-server-deploy'

        // Jenkins Config File ID (.env 파일)
        ENV_CONFIG_FILE_ID = 'commu-env-dev'

        // Storage 경로
        STORAGE_PATH = '/var/www/laravel-commu-dev-storage'

        // Slack 설정
        SLACK_CHANNEL = '#deployments'
    }

    stages {
        // ==========================================
        // Base 이미지 빌드 (수동 실행)
        // ==========================================
        stage('Build Base Image') {
            when {
                expression { params.ACTION == 'build-base' }
            }
            steps {
                script {
                    currentBuild.displayName = "#${BUILD_NUMBER} - build-base (dev)"
                }
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: params.BRANCH]],
                    userRemoteConfigs: [[
                        url: env.GIT_REPO,
                        credentialsId: env.GIT_CREDENTIALS_ID
                    ]]
                ])
                sh """
                    docker build \
                        -f docker/Dockerfile.base \
                        -t ${DOCKER_IMAGE_BASE}:latest \
                        .
                """
                echo "Base image built: ${DOCKER_IMAGE_BASE}:latest"
            }
        }

        // ==========================================
        // 배포: 환경 준비
        // ==========================================
        stage('Prepare Environment') {
            when {
                expression { params.ACTION == 'deploy' }
            }
            steps {
                script {
                    currentBuild.displayName = "#${BUILD_NUMBER} - deploy-dev (${params.BRANCH})"

                    // Base 이미지 존재 확인
                    def baseImageExists = sh(
                        script: "docker images -q ${DOCKER_IMAGE_BASE}:latest",
                        returnStdout: true
                    ).trim()

                    if (!baseImageExists) {
                        error("Base image not found. Run 'build-base' action first.")
                    }

                    // Storage 디렉토리 초기화 (최초 배포 시)
                    sh """
                        mkdir -p ${STORAGE_PATH}/app/public
                        mkdir -p ${STORAGE_PATH}/framework/cache/data
                        mkdir -p ${STORAGE_PATH}/framework/sessions
                        mkdir -p ${STORAGE_PATH}/framework/views
                        mkdir -p ${STORAGE_PATH}/logs
                        chown -R www-data:www-data ${STORAGE_PATH} || true
                        chmod -R 775 ${STORAGE_PATH}
                    """

                    // Docker 네트워크 생성 (없으면 생성)
                    sh """
                        docker network create laravel_network 2>/dev/null || true
                    """
                }
            }
        }

        // ==========================================
        // 배포: 코드 업데이트
        // ==========================================
        stage('Update Code') {
            when {
                expression { params.ACTION == 'deploy' }
            }
            steps {
                script {
                    // 배포 디렉토리 생성
                    sh "mkdir -p ${DEPLOY_PATH}"

                    // Git 저장소 존재 여부 확인
                    def gitExists = sh(
                        script: "docker run --rm -v ${DEPLOY_PATH}:${DEPLOY_PATH} -w ${DEPLOY_PATH} alpine:latest test -d .git && echo 'yes' || echo 'no'",
                        returnStdout: true
                    ).trim()

                    if (gitExists == 'no') {
                        // 최초 배포: 저장소 클론
                        echo "Initial deployment: Cloning repository..."
                        sh """
                            docker run --rm \
                                -v ${DEPLOY_PATH}:${DEPLOY_PATH} \
                                -v /root/.ssh:/root/.ssh:ro \
                                alpine/git:latest \
                                clone ${GIT_REPO} ${DEPLOY_PATH}
                        """
                    }

                    // Git pull
                    sh """
                        docker run --rm \
                            --entrypoint sh \
                            -v ${DEPLOY_PATH}:${DEPLOY_PATH} \
                            -v /root/.ssh:/root/.ssh:ro \
                            -w ${DEPLOY_PATH} \
                            alpine/git:latest \
                            -c "git config --global --add safe.directory ${DEPLOY_PATH} && git fetch origin && git checkout ${params.BRANCH} && git pull origin ${params.BRANCH}"
                    """

                    // 배포 버전 기록
                    env.DEPLOY_VERSION = sh(
                        script: "docker run --rm -v ${DEPLOY_PATH}:${DEPLOY_PATH} -w ${DEPLOY_PATH} alpine/git:latest rev-parse --short HEAD",
                        returnStdout: true
                    ).trim()

                    env.DEPLOY_TIMESTAMP = sh(
                        script: "date +%Y%m%d-%H%M%S",
                        returnStdout: true
                    ).trim()

                    env.VERSION_TAG = "${env.DEPLOY_TIMESTAMP}-${env.DEPLOY_VERSION}"
                    echo "Deploying version: ${env.VERSION_TAG}"
                }
            }
        }

        // ==========================================
        // 배포: 의존성 설치 및 빌드
        // ==========================================
        stage('Install Dependencies') {
            when {
                expression { params.ACTION == 'deploy' }
            }
            steps {
                sh """
                    docker run --rm \
                        -v ${DEPLOY_PATH}:/var/www/html \
                        -w /var/www/html \
                        ${DOCKER_IMAGE_BASE}:latest \
                        sh -c "composer install --no-dev --optimize-autoloader --no-interaction && npm ci --production=false && npm run build"
                """
            }
        }

        // ==========================================
        // 배포: .env 파일 주입
        // ==========================================
        stage('Inject Environment') {
            when {
                expression { params.ACTION == 'deploy' }
            }
            steps {
                configFileProvider([
                    configFile(fileId: env.ENV_CONFIG_FILE_ID, variable: 'ENV_FILE_PATH')
                ]) {
                    sh """
                        cat \${ENV_FILE_PATH} | docker run --rm -i \
                            -v ${DEPLOY_PATH}:/var/www/html \
                            alpine:latest \
                            sh -c 'cat > /var/www/html/.env'
                    """
                    echo ".env file injected from Jenkins Config File Provider"
                }
            }
        }

        // ==========================================
        // 배포: 컨테이너 시작
        // ==========================================
        stage('Deploy Container') {
            when {
                expression { params.ACTION == 'deploy' }
            }
            steps {
                script {
                    // 기존 컨테이너 중지
                    sh """
                        docker stop ${PROJECT_NAME} 2>/dev/null || true
                        docker rm ${PROJECT_NAME} 2>/dev/null || true
                    """

                    // 새 컨테이너 시작
                    sh """
                        docker run --rm \
                            -v /var/run/docker.sock:/var/run/docker.sock \
                            -v ${DEPLOY_PATH}:${DEPLOY_PATH} \
                            -w ${DEPLOY_PATH} \
                            -e APP_PATH=${DEPLOY_PATH} \
                            -e STORAGE_PATH=${STORAGE_PATH} \
                            -e ENV_FILE=${DEPLOY_PATH}/.env \
                            docker:cli \
                            docker compose -f docker/docker-compose.dev.yml up -d dev
                    """

                    // Storage 권한 설정 및 Laravel 초기화
                    sh """
                        sleep 5
                        docker exec ${PROJECT_NAME} chown -R www-data:www-data /var/www/html/storage
                        docker exec ${PROJECT_NAME} chmod -R 775 /var/www/html/storage
                        docker exec ${PROJECT_NAME} php artisan storage:link || true
                        docker exec ${PROJECT_NAME} php artisan config:cache || true
                        docker exec ${PROJECT_NAME} php artisan route:cache || true
                        docker exec ${PROJECT_NAME} php artisan view:cache || true
                        docker exec ${PROJECT_NAME} php artisan migrate --force || true
                    """

                    // OAuth 키 권한 수정 (chmod -R 775 이후에 실행해야 함, Passport 보안 요구사항: 600/660)
                    sh """
                        docker exec ${PROJECT_NAME} sh -c 'if [ -f /var/www/html/storage/oauth-private.key ]; then chmod 600 /var/www/html/storage/oauth-private.key && chmod 660 /var/www/html/storage/oauth-public.key; fi' || true
                    """
                }
            }
        }

        // ==========================================
        // 배포: 헬스체크
        // ==========================================
        stage('Health Check') {
            when {
                expression { params.ACTION == 'deploy' }
            }
            steps {
                script {
                    def maxRetries = 30
                    def retryCount = 0
                    def healthy = false

                    while (retryCount < maxRetries && !healthy) {
                        sleep(2)
                        def status = sh(
                            script: "docker exec ${PROJECT_NAME} curl -sf http://localhost/up || echo 'unhealthy'",
                            returnStdout: true
                        ).trim()

                        if (status != 'unhealthy') {
                            healthy = true
                            echo "Health check passed!"
                        } else {
                            retryCount++
                            echo "Health check attempt ${retryCount}/${maxRetries}..."
                        }
                    }

                    if (!healthy) {
                        // 실패 시 컨테이너 로그 출력
                        sh "docker logs --tail 50 ${PROJECT_NAME} || true"
                        error("Health check failed after ${maxRetries} attempts")
                    }
                }
            }
        }

        // ==========================================
        // 배포: 정리
        // ==========================================
        stage('Cleanup') {
            when {
                expression { params.ACTION == 'deploy' }
            }
            steps {
                script {
                    // npm 캐시 정리
                    sh """
                        docker run --rm \
                            -v ${DEPLOY_PATH}:/var/www/html \
                            alpine:latest \
                            rm -rf /var/www/html/node_modules/.cache 2>/dev/null || true
                    """
                }
            }
        }
    }

    post {
        success {
            script {
                def message = ""
                switch(params.ACTION) {
                    case 'deploy':
                        message = "[DEV] 배포 성공: ${PROJECT_NAME} v${env.VERSION_TAG ?: 'N/A'}"
                        break
                    case 'build-base':
                        message = "[DEV] Base 이미지 빌드 성공: ${DOCKER_IMAGE_BASE}"
                        break
                }

                try {
                    slackSend(
                        channel: env.SLACK_CHANNEL,
                        color: 'good',
                        message: """
                            *${message}*
                            - Branch: ${params.BRANCH}
                            - Build: #${BUILD_NUMBER}
                            - URL: https://dev-blogs.shaul.link
                        """.stripIndent()
                    )
                } catch (Exception e) {
                    echo "Slack notification skipped: ${e.message}"
                }
            }
        }
        failure {
            script {
                def message = ""
                switch(params.ACTION) {
                    case 'deploy':
                        message = "[DEV] 배포 실패: ${PROJECT_NAME}"
                        break
                    case 'build-base':
                        message = "[DEV] Base 이미지 빌드 실패: ${DOCKER_IMAGE_BASE}"
                        break
                }

                try {
                    slackSend(
                        channel: env.SLACK_CHANNEL,
                        color: 'danger',
                        message: """
                            *${message}*
                            - Branch: ${params.BRANCH}
                            - Build: #${BUILD_NUMBER}
                            - Console: ${BUILD_URL}console
                        """.stripIndent()
                    )
                } catch (Exception e) {
                    echo "Slack notification skipped: ${e.message}"
                }
            }
        }
    }
}
